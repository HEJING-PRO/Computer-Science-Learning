# 第三章 Java 的基本程序设计结构

## 3.1 一个简单的 Java 应用程序

1. 一个源文件（`.java`）中只能有一个公共类（`public`），且文件名必须与公共类的名字相同。

2. Java 程序执行流程：源文件 →  字节码文件  → 结果

   ```java
   /* 编译成字节码文件 */
   javac Hello.java
   /* 运行，文件名后不能添加扩展名 */
   java Hello
   ```

   - 编译：利用编译器（`javac.exe`）将源文件（`.java`）编译成 JVM 可识别的字节码文件（`.class`）。

   - 运行：利用运行工具（`java.exe`）对字节码文件进行执行，本质是将字节码文件装载到 JVM 执行。

     > 注：对修改后的源文件需要重新编译，生成新的字节码文件后再执行。

3. 运行已编译的程序时，虚拟机通常从公共类中的`main`方法开始执行，可以将`main`方法写在非`public`中，并指定运行此非`public`类，`main`方法必须声明为`public`、必须是静态的。

   ```java
   public static void main(String[] args) {
       ...
   }
   ```

## 3.2 注释

1. 单行注释：`//`；

2. 多行注释：`/* */`；

3. 文档注释：`/** */`，注释内容可以被 JDK 提供的工具`javadoc`所解析，生成一套以网页文件形式呈现的该程序的说明文档，通常写在类前。

   ```bash
   # 需要说明要标签，如 author、version 等
   javadoc -d d:/demo -author -version Hello.java
   ```


## 3.3 数据类型

1. Java 是一种强类型语言，即必须为每一个变量声明一种类型。

2. 进制

   - 二进制：以`0b`或`0B`开头；

   - 八进制：以数字`0`开头；
   - 十六进制：以`0x`或`0X`开头。

3. 基本数据类型，各种整数类型有**固定的范围和字段长度**，不受操作系统的影响，以保证程序的可移植性。

   ![](https://gitee.com/hejing-pro/image-rep/raw/master/202311012217439.png)

   - 整数类型：**整型常量默认为**`int`**型**，声明为`long`型的常量后必须添加`l`或`L`；通常情况下使用`int`类型。

   - 浮点类型：在机器中的存放形式为“符号位 + 指数位 + 尾数位”；位数为可能丢失，可能造成精度损失，因此小数均为近似值；**浮点数常量默认为**`double`**型**，声明`float`型常量，必须添加`f`或`F`；常量具有两种表示形式，即十进制数形式和科学计数法形式；通常情况下使用`double`类型；**当对运算结果是小数的数据进行相等判断时，应当以两个数的差值的绝对值在某个精读范围内判断**，若为查询得到的数据或直接赋值的数据，可直接使用等号判断。

     ```java
     double fir = 2.7;
     /* 运算结果为 2.699999999997 */
     double sec = 8.1 / 3;
     /* 错误写法 */
     if(fir == sec){}
     /* 正确写法 */
     if(Math.abs(fir - sec) < num){}
     ```
     
   - 字符类型：使用单引号，可表示单个字符；可存放汉字；可以直接存放一个数字，输出对应的 ASCII 码字符。在内存中**存储**的是字符对应的 **ASCII 码值的二进制形式**，读取时则是先将二进制转换为十进制，再显示对应的字符。在 Java 中，`char`类型描述 UTF-16 编码中的一个代码单元。

     > 强烈建议不在程序中使用`char`类型，除非确实需要处理 UTF-16 代码单元。

   - 布尔类型：不可以使用 0 或非 0 数字替代`false`或`true`。

   - 字符编码

     - ASCII 码：一个字节表示，一共 128 个字符。
     - Unicode：使用固定大小的编码，使用两个字节表示字符，字符和汉字均占用 2 个字节。
     - UTF-8：可变大小编码，字符使用 1 个字节，汉字使 2 个字节。
     - GBK：可表示汉字，字母使用 1 个字节，汉字使用 2 个字节。

   - 自动类型转换：当进行赋值或运算时，**低精度类型自动转换为高精度类型**。

     - `char` → `int` → `long` → `float` → `double`；
     - `byte` → `short` → `int` → `long` → `float` → `double`；
     - 当多种类型的数据混合运算时，自动将所有数据转换成精读最大的数据类型，然后进行计算；
     - 当将高精度数据赋值给低精度变量时会报错，反之则会进行自动类型转换；
     - `byte`、`short`和`char`之间不会相互转换；
     - 布尔类型不参与转换；
     - `byte`、`short`、`char`可进行计算，计算时先转换为`int`型，即三者的混合运算结果为`int`型；
     - **自动提升规则：表达式结果的类型自动提升为操作数中的最大精度类型。**

   - 强制类型转换：将高精度数据类型转换为低精度数据类型，使用时需使用强制转换符`()`，可能会造成精度损失；强制符号仅对最近的操作数有效；`char`类型可以保存`int`型的常量值，但不能保存`int`型的变量值，需要使用强制转换；`byte`和`short`类型进行运算时，当做`int`类型处理。

     ```java
     /* 将 int 型常量值赋值给 char 类型变量，允许，仅需常量在 char 可表示的范围内即可 */
     char fir = 97;
     int num = 98;
     /* 将 int 型变量赋值给 char 型变量，不允许 */
     char sec = num;
     ```

   - 基本数据类型转换为`String`

     ```java
     int num = 1;
     String str = num + "";
     ```

   -  `String`转换为基本数据类型：使用基本数据类型对应的包装类的对应方法得到基本数据类型。

     ```java
     String str = "99";
     int num = Integer.parseInt(str);
     ```

   - `String`转换为`char`：使用索引返回对应的字符。

     ```java
     string name = "mike";
     char fir = name.charAt(1);
     ```

   - 规则：所有浮点数值计算都遵循 IEEE 754 规范，分别使用正无穷大（`Double.POSITIVE_INFINITY`）、负无穷大（`Double.NEGATIVE_INFINITY`）、`NaN`（`Double.NaN`）表示溢出或出错情况。

     > 注：所有非数值的值均互不相等，因此不能使用`num == Double.NaN`检测一个特定值是否等于`Double.NaN`，可以使用`Double.isNaN(num)`判断。


## 3.4 变量与常量

1. 变量：代表一块指定大小的内存空间，不同类型的变量占用不同大小的空间；变量必须先声明后使用；变量在同一作用域内不可重名。

2. 声明变量：逐一声明每个变量可提高程序的可读性。变量的声明尽可能靠近变量第一次使用的地方。声明一个变量后，必须使用赋值语句对变量进行显式初始化，不可使用未初始化的变量的值。

3. 常量：利用`final`关键字指示常量，常量使用全大写。类常量使用`static final`修饰，可在一个类的多个方法中使用。

   ```java
   final int AGE = 12;
   
   public class ClassName {
       // 设置类常量
       public static final double PI = 3.14;
   }
   ```

4. 枚举类型：变量的取值仅在一个有限的集合内。枚举类型的变量只能存储类型生命中给定的某个枚举值或`null`。

   ```java
   // 自定义枚举类型
   enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };
   // 声明变量
   Size size = Size.SMALL;
   ```


## 3.5 运算符

1. 算术运算符
   - `+`：当两侧均为数值类型是，进行加法运算；当有一侧为字符串类型时，进行拼接运算。
   - `/`：参与运算的两个操作数均为整数时，表示整数除法，否则表示浮点数除法。
   - `%`：$a \% b=a-a/b*b$。

2. 二元运算符：`+=` 等，若运算符得到一个值，其类型与左侧操作数的类型不同，则会发生强制类型转换。

   ```java
   int num = 15;
   // 合法，将把 num 设置成 (int)(num+3)
   num += 3;
   ```

3. 自增/自减运算符：使用临时变量。

   ```java
   int i = 1;
   i = i++;
   /* 输出结果为 1；
      temp = i;
      i = i + 1;
      i = temp;
   */
   System.out.println(i);
   ```

   ```java
   int i = 1;
   i = i++;
   /* 输出结果为 2；
      i = i + 1;
      temp = i;
      i = temp;
   */
   System.out.println(i);
   ```

4. 逻辑运算符

   - 短路与（`&&`）与逻辑与（`&`）的区别：对于短路与，若第一个条件为假，则后续条件不再判断；对于逻辑与，即使第一个条件为假，后续条件依然判断。**通常使用短路与，效率高**。
   - 短路或（`||`）与逻辑或（`|`）的区别：对于短路或，若第一个条件为真，则或许条件不再判断；对于逻辑或，即使第一个条件为真，后续条件依然判断。**通常使用短路或，效率高**。
   - 逻辑亦或（`^`）：当两个操作数为不同的布尔值时，结果为真，否则为假。
   - 复合赋值运算符：会进行类型转换。

5. 位运算符

   - 算术右移（`>>`）：低位溢出，符号位不变，并用符号位补溢出的高位；

   - 算术左移（`<<`）：符号位不变，低位补 `0`；

   - 逻辑右移（`>>>`）：无符号右移，低位溢出，高位补`0`。

   > 注：不存在逻辑左移。

## 3.6 字符串

1. 不可变字符串：无法修改字符串中的单个字符。

2. 检测字符串是否相等：`fir.equals(sec)`，`fir`和`sec`可以是字符串变量，也可以是字符串字面量。**一定不要使用`==`检测两个字符串是否相等，其只能确定两个字符串是否在同一个内存空间中**。只有字符串字面量是共享的，`+`和`substring`等操作得到的字符串不共享。

3. 构建字符串：利用`StringBuilder`将较短的字符串构建长字符串，`StringBuilder`相比于`StringBuffer`效率稍低，但允许多线程方式添加或删除字符。

   ```java
   // 构建空的构造器
   StringBuilder builder = new StringBuilder();
   // 当需要添加一部分内容时，调用 append() 方法
   builder.append(str);
   // 字符串构建完成时调用 toString() 方法，得到一个 String 对象
   String str = builder.toString();
   ```

## 3.7 输入输出

1. 控制台输入

   ```java
   Scanner scan = new Scanner(System.in);
   String str = scan.next();
   // 读取一行
   String name = scan.nextLine();
   ```

## 3.8 控制流

1. 块作用域：用于确定变量的作用域，一个块可嵌套在另一个块中，不能在嵌套的两个块中声明同名的变量。
2. 顺序控制：程序从上到下 逐行执行，中间没有任何判断和跳转；定义变量时采用**前向引用**，即先声明后使用。
3. 多重循环之`switch`语句：从与选项匹配的`case`标签开始执行，直到遇到`break`语句，或者执行到`switch`语句的结束处位置，若无相匹配的`case`标签，但是有`default`子句，则执行该子句。若在`case`分支语句的末尾不存在`break`语句，则会继续执行下一个`case`分支语句，故在程序中不使用`switch`语句。
4. `return`：在方法中使用时，表示跳出所在的方法；在`main`函数中使用时，会退出程序。

## 3.9 大数

1. `BigInteger`：实现任意精度的整数运算。

   ```java
   // 将普通数值转换为大数
   BigInteger bigInt = BigInteger.valueOf(100);
   ```

2. `BigDecimal`：实现任意精度的浮点数运算。

   注：不能使用算术运算符处理大数，需使用大数类中的`add`和`multiply`方法。

## 3.10 数组

1. 定义

   ```java
   // 创建数组并初始化
   int[] nums = {};
   // 创建数组，指定长度
   int[] name = new int[len]; 
   ```

2. 默认初始化：创建数字数组时，所有元素都初始化为$0$，布尔数组的元素初始化为`false`，对象数组的元素初始化为`null`。

3. `for each`循环：用于依次处理数组（或其他元素集合）中的每一个元素。**集合元素必须是实现了`Iterable`接口的类对象**。

   ```java
   for(int ele : collection){}
   ```

4. 打印数组中的所有值：`System.out.println(Arrays.toString(arr))`。

5. 数组拷贝

   - 浅拷贝：基本数据类型赋值方式为值拷贝，各变量的值相互独立；数组在默认情况下赋值方式为引用赋值，赋的值是地址，因此数组名保存的是堆内存中的一个地址，若将一个数组赋值给另一个数组，则**两个数组名中保存的是同一个内存地址**，故数组之间会相互影响。

   - 深拷贝：将一个数组中的所有值拷贝到新的数组中。

     ```java
     // 第二个参数是新数组的长度，若数组元素是数值型时，额外元素被赋值为 0，若数组元素为布尔型，则赋值为 false，若长度小于原始数组的长度，则仅拷贝前面的值。
     int[] newArr = Arrays.copyOf(oldArr, oldArr.length);
     ```
     
     > 注：`[]`运算符会完成越界检查，且没有指针运算，即无法通过对数组名加一得到数组中的下一个元素。

6. 多维数组

   - 遍历多维数组

     ```java
     for(int[] row : arr){
         for(int ele : row){
             ...
         }
     }
     ```

   - 二维数组内存布局：二位数组的内存布局：二维数组的每个元素均为一个一维数组。二维数组的名字位于栈内存中，存储一个一维数组的地址，该一维数组中存放的各一维数组的地址，即`arr[i][j]`的`arr[i]`表示一个地址，指向堆内存中的一个数组，`arr[i][j]`则是各数组中的元素。

     <img src="https://gitee.com/hejing-pro/image-rep/raw/master/202311031038736.png" alt="image.png" style="zoom: 50%;" />





